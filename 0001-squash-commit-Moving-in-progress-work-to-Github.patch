From a183a39854086a0db9f044aa1819484e88e84dcd Mon Sep 17 00:00:00 2001
From: Gautam Kumar <gauta@amazon.com>
Date: Thu, 21 Nov 2019 00:07:28 -0800
Subject: [PATCH] [squash commit: Moving in-progress work to Github]

Adding helm chart for hpo and batch transform

cr https://code.amazon.com/reviews/CR-15895790

Model name to have generation

EndpointConfig update

Refactor hosting deployment controller

Handling update, create and delete

Rebase error

Truncating SageMaker names for models and endpoint configs

Removing endpoint reconciler

Cleaning up for CR

cr https://code.amazon.com/reviews/CR-15844884

CR feedback

Fixing Coverlay build

HostingDeployment delete no longer crashes operator if endpointconfig names can't be found

cr https://code.amazon.com/reviews/CR-15926882
---
 build-tools/bin/custom-build                  |  10 +-
 .../endpointconfig_controller.go              |  12 +-
 .../hosting/endpoint_reconciler.go            | 175 ----------
 .../hosting/endpoint_reconciler_test.go       |   4 +
 .../hosting/endpointconfig_reconciler.go      | 179 ++++++----
 .../hosting/endpointconfig_reconciler_test.go |  35 +-
 .../hosting/hostingdeployment_controller.go   | 328 +++++++++++++-----
 .../hostingdeployment_controller_test.go      | 112 +-----
 .../controllers/hosting/model_reconciler.go   |  27 +-
 .../hosting/model_reconciler_test.go          |  22 +-
 .../controllers/model/model_controller.go     |  11 +-
 .../sdkutil/clientwrapper/sagemaker_client.go |  59 +++-
 .../charts/batch-transform-jobs/Chart.yaml    |   9 +
 .../batch-transform-jobs/templates/NOTES.txt  |  12 +
 .../templates/batch-transform-job.yaml        |  21 ++
 .../charts/batch-transform-jobs/values.yaml   |  11 +
 .../hyperparameter-tuning-jobs/Chart.yaml     |   9 +
 .../templates/NOTES.txt                       |  12 +
 .../templates/hpo-job.yaml                    |  74 ++++
 .../hyperparameter-tuning-jobs/values.yaml    |  57 +++
 .../smlogs-kubectl-plugin/go.mod              |   2 +-
 21 files changed, 719 insertions(+), 462 deletions(-)
 delete mode 100644 sagemaker-k8s-operator/controllers/hosting/endpoint_reconciler.go
 create mode 100644 sagemaker-k8s-operator/hack/charts/batch-transform-jobs/Chart.yaml
 create mode 100644 sagemaker-k8s-operator/hack/charts/batch-transform-jobs/templates/NOTES.txt
 create mode 100644 sagemaker-k8s-operator/hack/charts/batch-transform-jobs/templates/batch-transform-job.yaml
 create mode 100644 sagemaker-k8s-operator/hack/charts/batch-transform-jobs/values.yaml
 create mode 100644 sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/Chart.yaml
 create mode 100644 sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/templates/NOTES.txt
 create mode 100644 sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/templates/hpo-job.yaml
 create mode 100644 sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/values.yaml

diff --git a/build-tools/bin/custom-build b/build-tools/bin/custom-build
index d07523f..6b4ac81 100755
--- a/build-tools/bin/custom-build
+++ b/build-tools/bin/custom-build
@@ -21,7 +21,7 @@ echo "Creating coverage directory"
 buildroot="$(bpath package-build-root)"
 # Taken from https://code.amazon.com/packages/CoverlayWorkflowService/blobs/ee688ce79944dcebb92fa42057ac83eff4351e13/--/src/com/amazon/coverlayworkflowservice/build/CodeCoverageFinder.java#L58
 coveragedir="${buildroot}/brazil-documentation/coverage"
-mkdir -p "${coveragedir}/sagemaker-k8s-operator" "${coveragedir}/smlogs-kubectl-plugin" "${coveragedir}/smctl"
+mkdir -p "${coveragedir}/sagemaker-k8s-operator" "${coveragedir}/smlogs-kubectl-plugin"
 
 echo "Installing kubebuilder test binaries"
 # Taken from https://book.kubebuilder.io/quick-start.html#installation
@@ -41,13 +41,7 @@ make test
 cp cover.out "${coveragedir}/sagemaker-k8s-operator/coverage.out"
 popd
 
-pushd smctl 
-echo "Running tests for $(pwd)"
-make test
-cp cover.out "${coveragedir}/smctl/coverage.out"
-popd
-
-pushd smlogs-kubectl-plugin
+pushd sagemaker-k8s-operator/smlogs-kubectl-plugin
 echo "Running tests for $(pwd)"
 make test
 cp cover.out "${coveragedir}/smlogs-kubectl-plugin/coverage.out"
diff --git a/sagemaker-k8s-operator/controllers/endpointconfig/endpointconfig_controller.go b/sagemaker-k8s-operator/controllers/endpointconfig/endpointconfig_controller.go
index dbf2022..fe775cc 100644
--- a/sagemaker-k8s-operator/controllers/endpointconfig/endpointconfig_controller.go
+++ b/sagemaker-k8s-operator/controllers/endpointconfig/endpointconfig_controller.go
@@ -330,9 +330,17 @@ func (r *EndpointConfigReconciler) updateStatusWithAdditional(ctx reconcileReque
 	return nil
 }
 
-// TODO Make sure this fits SageMaker validation https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateEndpointConfig.html#SageMaker-CreateEndpointConfig-request-EndpointConfigName
 func generateEndpointConfigName(endpointConfig *endpointconfigv1.EndpointConfig) string {
-	return endpointConfig.ObjectMeta.GetName() + "-" + strings.Replace(string(endpointConfig.ObjectMeta.GetUID()), "-", "", -1)
+	sageMakerMaxNameLen := 63
+	name := endpointConfig.ObjectMeta.GetName()
+	requiredPostfix := "-" + strings.Replace(string(endpointConfig.ObjectMeta.GetUID()), "-", "", -1)
+
+	sageMakerEndpointConfigName := name + requiredPostfix
+	if len(sageMakerEndpointConfigName) > sageMakerMaxNameLen {
+		sageMakerEndpointConfigName = name[:sageMakerMaxNameLen-len(requiredPostfix)] + requiredPostfix
+	}
+
+	return sageMakerEndpointConfigName
 }
 
 // TODO add code that ignores status, metadata updates.
diff --git a/sagemaker-k8s-operator/controllers/hosting/endpoint_reconciler.go b/sagemaker-k8s-operator/controllers/hosting/endpoint_reconciler.go
deleted file mode 100644
index 3c8e762..0000000
--- a/sagemaker-k8s-operator/controllers/hosting/endpoint_reconciler.go
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
-Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package hosting
-
-import (
-	"context"
-	"fmt"
-	"strings"
-
-	"github.com/go-logr/logr"
-	"github.com/pkg/errors"
-	"sigs.k8s.io/controller-runtime/pkg/client"
-
-	"github.com/aws/aws-sdk-go-v2/service/sagemaker"
-	"go.amzn.com/sagemaker/sagemaker-k8s-operator/controllers/sdkutil"
-	"go.amzn.com/sagemaker/sagemaker-k8s-operator/controllers/sdkutil/clientwrapper"
-
-	endpointconfigv1 "go.amzn.com/sagemaker/sagemaker-k8s-operator/api/v1/endpointconfig"
-	hostingv1 "go.amzn.com/sagemaker/sagemaker-k8s-operator/api/v1/hostingdeployment"
-)
-
-// Type that returns an instantiated EndpointReconciler given parameters.
-type EndpointReconcilerProvider func(client.Client, logr.Logger, clientwrapper.SageMakerClientWrapper) EndpointReconciler
-
-// Helper method to create a EndpointReconciler.
-func NewEndpointReconciler(client client.Client, log logr.Logger, sageMakerClient clientwrapper.SageMakerClientWrapper) EndpointReconciler {
-	return &endpointReconciler{
-		k8sClient:       client,
-		log:             log.WithName("EndpointReconciler"),
-		sageMakerClient: sageMakerClient,
-	}
-}
-
-// Helper type that is responsible for reconciling Endpoints of an endpoint.
-type EndpointReconciler interface {
-	Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, actualDeployment *sagemaker.DescribeEndpointOutput) error
-}
-
-// Concrete implementation of EndpointReconciler.
-type endpointReconciler struct {
-	EndpointReconciler
-
-	k8sClient       client.Client
-	log             logr.Logger
-	sageMakerClient clientwrapper.SageMakerClientWrapper
-}
-
-// Reconcile actual state with desired state.
-// If the SageMaker Endpoint does not exist, create it. This obtains the necessary EndpointConfigName from
-// the Kubernetes EndpointConfig.
-func (r *endpointReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, actualDeployment *sagemaker.DescribeEndpointOutput) error {
-
-	r.log.Info("Reconciling Endpoints")
-
-	var err error
-	var desiredEndpoint *sagemaker.CreateEndpointInput
-	if desiredEndpoint, err = r.getDesiredEndpoint(ctx, desiredDeployment); err != nil {
-		return errors.Wrap(err, "Unable to determine desired endpoint")
-	}
-
-	r.log.Info("Desired endpoint", "endpoint", desiredEndpoint)
-
-	var needsCreate bool
-	if needsCreate, err = r.determineIfNeedsCreate(desiredEndpoint, actualDeployment); err != nil {
-		return errors.Wrap(err, "Unable to determine if the Endpoint needs to be created.")
-	}
-
-	r.log.Info("Endpoint needs create", "needsCreate", needsCreate)
-
-	var needsDelete bool
-	needsDelete = !desiredDeployment.ObjectMeta.GetDeletionTimestamp().IsZero()
-
-	if needsCreate && !needsDelete {
-		if _, err := r.sageMakerClient.CreateEndpoint(ctx, desiredEndpoint); err != nil {
-			return errors.Wrap(err, "Unable to create Endpoint")
-		}
-	}
-
-	// Try to delete only if its marked for deletion and not already being deleted
-	if needsDelete { //&& (actualDeployment.EndpointStatus != DeletingEndpointStatus) { TODO(cade) fix this when doing endpoint update.
-		// Client returns err=nil in case of 404, however returns error if update-in-progress
-		if _, err := r.sageMakerClient.DeleteEndpoint(ctx, desiredEndpoint.EndpointName); err != nil {
-			return errors.Wrap(err, "Unable to delete Endpoint")
-		}
-	}
-
-	// TODO Need creation verification strategy that doesn't use exponential backoff.
-
-	return nil
-}
-
-// Get the desired Endpoint.
-func (r *endpointReconciler) getDesiredEndpoint(ctx context.Context, deployment *hostingv1.HostingDeployment) (*sagemaker.CreateEndpointInput, error) {
-
-	var err error
-	var endpointConfigName *string
-	if endpointConfigName, err = r.resolveSageMakerEndpointConfigName(ctx, deployment); err != nil {
-		// If we are on create path and failed to resolve endpointconfig
-		// then we need to raise the error.
-		// If we are on delete path then error does not matter.
-		if deployment.ObjectMeta.GetDeletionTimestamp().IsZero() {
-			return nil, err
-		}
-	}
-
-	endpointName := GetSageMakerEndpointName(*deployment)
-
-	desiredEndpoint := sagemaker.CreateEndpointInput{
-		EndpointConfigName: endpointConfigName,
-		EndpointName:       &endpointName,
-		Tags:               sdkutil.ConvertTagSliceToSageMakerTagSlice(deployment.Spec.Tags),
-	}
-
-	return &desiredEndpoint, nil
-}
-
-// Get the SageMaker Endpoint name given a HostingDeployment.
-// TODO Make sure this fits SageMaker validation https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateEndpoint.html#SageMaker-CreateEndpoint-request-EndpointName
-func GetSageMakerEndpointName(desiredDeployment hostingv1.HostingDeployment) string {
-	SMMaxLen := 63
-	name := desiredDeployment.ObjectMeta.GetName()
-	uid := strings.Replace(string(desiredDeployment.ObjectMeta.GetUID()), "-", "", -1)
-	smEndpointName := name + "-" + uid
-	if len(smEndpointName) > SMMaxLen {
-		smEndpointName = name[:SMMaxLen-len(uid)-1] + "-" + uid
-	}
-	return smEndpointName
-}
-
-// For a given HostingDeployment, get the SageMaker EndpointConfig name.
-// This works by reading the status of the EndpointConfig Kubernetes object.
-func (r *endpointReconciler) resolveSageMakerEndpointConfigName(ctx context.Context, deployment *hostingv1.HostingDeployment) (*string, error) {
-
-	if deployment == nil {
-		return nil, fmt.Errorf("Unable to resolve SageMaker EndpointConfig name for nil deployment")
-	}
-
-	namespacedName := GetKubernetesEndpointConfigNamespacedName(*deployment)
-
-	var endpointConfig endpointconfigv1.EndpointConfig
-	if err := r.k8sClient.Get(ctx, namespacedName, &endpointConfig); err != nil {
-		return nil, errors.Wrapf(err, "Unable to resolve SageMaker EndpointConfig name for EndpointConfig '%s'", namespacedName)
-	}
-
-	if endpointConfig.Status.SageMakerEndpointConfigName == "" {
-		return nil, fmt.Errorf("EndpointConfig '%s' does not have a SageMakerEndpointConfigName", namespacedName)
-	}
-
-	return &endpointConfig.Status.SageMakerEndpointConfigName, nil
-}
-
-// Determine if the Endpoint needs to be created.
-func (r *endpointReconciler) determineIfNeedsCreate(desiredEndpoint *sagemaker.CreateEndpointInput, actualState *sagemaker.DescribeEndpointOutput) (bool, error) {
-
-	if actualState == nil {
-		return true, nil
-	}
-
-	// TODO deep equality comparison to catch when the actual state drifted away from desired state.
-	return false, nil
-}
diff --git a/sagemaker-k8s-operator/controllers/hosting/endpoint_reconciler_test.go b/sagemaker-k8s-operator/controllers/hosting/endpoint_reconciler_test.go
index 104953b..8ac1e20 100644
--- a/sagemaker-k8s-operator/controllers/hosting/endpoint_reconciler_test.go
+++ b/sagemaker-k8s-operator/controllers/hosting/endpoint_reconciler_test.go
@@ -15,6 +15,9 @@ limitations under the License.
 
 package hosting
 
+/*
+// TODO(cdnamz) I am keeping these commented instead of deleting them as some bits will be useful when writing HostingDeployment controller tests.
+
 import (
 	. "container/list"
 	"context"
@@ -231,3 +234,4 @@ func createEndpointConfig(name, namespace, region string) endpointconfigv1.Endpo
 		},
 	}
 }
+*/
diff --git a/sagemaker-k8s-operator/controllers/hosting/endpointconfig_reconciler.go b/sagemaker-k8s-operator/controllers/hosting/endpointconfig_reconciler.go
index ac70268..cb4dd88 100644
--- a/sagemaker-k8s-operator/controllers/hosting/endpointconfig_reconciler.go
+++ b/sagemaker-k8s-operator/controllers/hosting/endpointconfig_reconciler.go
@@ -20,6 +20,7 @@ import (
 	"context"
 	"fmt"
 	"reflect"
+	"strconv"
 	"strings"
 
 	"github.com/go-logr/logr"
@@ -49,7 +50,7 @@ func NewEndpointConfigReconciler(client client.Client, log logr.Logger) Endpoint
 
 // Helper type that is responsible for reconciling EndpointConfigs of an endpoint.
 type EndpointConfigReconciler interface {
-	Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) error
+	Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, shouldDeleteUnusedResources bool) error
 	GetSageMakerEndpointConfigName(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) (string, error)
 }
 
@@ -66,9 +67,9 @@ var _ EndpointConfigReconciler = (*endpointConfigReconciler)(nil)
 // This will create, delete and update an EndpointConfig in Kubernetes.
 // The created EndpointConfig will point to actual SageMaker models. This function will
 // obtain the SageMaker model names from the Kubernetes model statuses.
-// After creation, it will verify that the EndpointConfig is created in SageMaker.
-// The same process will follow for delete and update except verification.
-func (r *endpointConfigReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) error {
+//
+// The parameter shouldDeleteUnusedResources controls whether unnecessary endpoint configs are deleted. This is useful when updating Endpoints.
+func (r *endpointConfigReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, shouldDeleteUnusedResources bool) error {
 
 	r.log.Info("Reconciling EndpointConfigs")
 
@@ -81,51 +82,69 @@ func (r *endpointConfigReconciler) Reconcile(ctx context.Context, desiredDeploym
 
 	r.log.Info("Desired endpoint config", "desired", desiredEndpointConfig)
 
-	var actualEndpointConfig *endpointconfigv1.EndpointConfig
-	if actualEndpointConfig, err = r.getActualEndpointConfigForHostingDeployment(ctx, desiredDeployment); err != nil {
+	var actualEndpointConfigs map[string]*endpointconfigv1.EndpointConfig
+	if actualEndpointConfigs, err = r.getActualEndpointConfigsForHostingDeployment(ctx, desiredDeployment); err != nil {
 		return errors.Wrap(err, "Unable to get actual endpoint config")
 	}
 
-	r.log.Info("Actual endpoint config", "actual", actualEndpointConfig)
+	r.log.Info("Actual endpoint config", "actual", actualEndpointConfigs)
 
-	action := r.determineActionForEndpointConfig(desiredEndpointConfig, actualEndpointConfig)
+	actions := r.determineActionForEndpointConfig(desiredEndpointConfig, actualEndpointConfigs)
 
-	r.log.Info("Action for endpoint config", "action", action)
+	for action, endpointConfigs := range actions {
 
-	if action == NeedsDelete {
-
-		if err := r.k8sClient.Delete(ctx, actualEndpointConfig); err != nil {
-			if !apierrs.IsNotFound(err) {
-				return errors.Wrapf(err, "Unable to delete Kubernetes EndpointConfig '%s'", types.NamespacedName{
-					Name:      actualEndpointConfig.ObjectMeta.Name,
-					Namespace: actualEndpointConfig.ObjectMeta.Namespace,
-				})
+		r.log.Info("action", "action", action, "ecs", getEndpointConfigNamesFromMap(endpointConfigs))
+		switch action {
+		case NeedsNoop:
+			// Do nothing.
+		case NeedsCreate:
+			for _, endpointConfig := range endpointConfigs {
+				if err := r.k8sClient.Create(ctx, endpointConfig); err != nil {
+					return errors.Wrapf(err, "Unable to create Kubernetes EndpointConfig '%s'", types.NamespacedName{
+						Name:      endpointConfig.ObjectMeta.Name,
+						Namespace: endpointConfig.ObjectMeta.Namespace,
+					})
+				}
+			}
+		case NeedsDelete:
+			if !shouldDeleteUnusedResources {
+				r.log.Info("Not deleting unused resources", "shouldDeleteUnusedResources", shouldDeleteUnusedResources)
+				break
+			}
+			for _, endpointConfig := range endpointConfigs {
+				if err := r.k8sClient.Delete(ctx, endpointConfig); err != nil {
+					if !apierrs.IsNotFound(err) {
+						return errors.Wrapf(err, "Unable to delete Kubernetes EndpointConfig '%s'", types.NamespacedName{
+							Name:      endpointConfig.ObjectMeta.Name,
+							Namespace: endpointConfig.ObjectMeta.Namespace,
+						})
+					}
+				}
+			}
+		case NeedsUpdate:
+			for _, endpointConfig := range endpointConfigs {
+				if err = r.k8sClient.Update(ctx, endpointConfig); err != nil {
+					return errors.Wrapf(err, "Unable to update Kubernetes EndpointConfig '%s'", types.NamespacedName{
+						Name:      endpointConfig.ObjectMeta.Name,
+						Namespace: endpointConfig.ObjectMeta.Namespace,
+					})
+				}
 			}
 		}
 
-	} else if action == NeedsCreate {
-		if err := r.k8sClient.Create(ctx, desiredEndpointConfig); err != nil {
-			return errors.Wrapf(err, "Unable to create Kubernetes EndpointConfig '%s'", types.NamespacedName{
-				Name:      desiredEndpointConfig.ObjectMeta.Name,
-				Namespace: desiredEndpointConfig.ObjectMeta.Namespace,
-			})
-		}
-	} else if action == NeedsUpdate {
-
-		toUpdate := actualEndpointConfig.DeepCopy()
-		toUpdate.Spec = desiredEndpointConfig.Spec
-
-		if err = r.k8sClient.Update(ctx, toUpdate); err != nil {
-			return errors.Wrapf(err, "Unable to update Kubernetes EndpointConfig '%s'", types.NamespacedName{
-				Name:      toUpdate.ObjectMeta.Name,
-				Namespace: toUpdate.ObjectMeta.Namespace,
-			})
-		}
 	}
-
 	return nil
 }
 
+// Helper method to get a slice of EndpointConfig names from a map.
+func getEndpointConfigNamesFromMap(m map[string]*endpointconfigv1.EndpointConfig) []string {
+	keys := []string{}
+	for k := range m {
+		keys = append(keys, k)
+	}
+	return keys
+}
+
 // Return a Kubernetes object representing the desired EndpointConfig. This performs some validation
 // on the ProductionVariants, and will return any error.
 func (r *endpointConfigReconciler) extractDesiredEndpointConfigFromHostingDeployment(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) (*endpointconfigv1.EndpointConfig, error) {
@@ -161,10 +180,15 @@ func (r *endpointConfigReconciler) extractDesiredEndpointConfigFromHostingDeploy
 
 	namespacedName := GetKubernetesEndpointConfigNamespacedName(*desiredDeployment)
 
+	// Add labels to endpointconfig that indicate which particular HostingDeployment
+	// owns it.
+	ownershipLabels := GetResourceOwnershipLabelsForHostingDeployment(*desiredDeployment)
+
 	desiredEndpointConfig := endpointconfigv1.EndpointConfig{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      namespacedName.Name,
 			Namespace: namespacedName.Namespace,
+			Labels:    ownershipLabels,
 		},
 		Spec: endpointconfigv1.EndpointConfigSpec{
 			ProductionVariants: productionVariants,
@@ -206,10 +230,13 @@ func GetKubernetesEndpointConfigNamespacedName(deployment hostingv1.HostingDeplo
 	k8sMaxLen := 253
 	name := deployment.ObjectMeta.GetName()
 	uid := strings.Replace(string(deployment.ObjectMeta.GetUID()), "-", "", -1)
-	endpointConfigName := name + "-" + uid
+	generation := strconv.FormatInt(deployment.ObjectMeta.GetGeneration(), 10)
+
+	requiredPostfix := "-" + generation + "-" + uid
+	endpointConfigName := name + requiredPostfix
 
 	if len(endpointConfigName) > k8sMaxLen {
-		endpointConfigName = name[:k8sMaxLen-len(uid)-1] + "-" + uid
+		endpointConfigName = name[:k8sMaxLen-len(requiredPostfix)] + requiredPostfix
 	}
 
 	return types.NamespacedName{
@@ -219,41 +246,65 @@ func GetKubernetesEndpointConfigNamespacedName(deployment hostingv1.HostingDeplo
 }
 
 // Get the existing Kubernetes EndpointConfig. If it does not exist, return nil.
-func (r *endpointConfigReconciler) getActualEndpointConfigForHostingDeployment(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) (*endpointconfigv1.EndpointConfig, error) {
+func (r *endpointConfigReconciler) getActualEndpointConfigsForHostingDeployment(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) (map[string]*endpointconfigv1.EndpointConfig, error) {
+	ownershipLabelSelector := client.MatchingLabels(GetResourceOwnershipLabelsForHostingDeployment(*desiredDeployment))
 
-	key := GetKubernetesEndpointConfigNamespacedName(*desiredDeployment)
-	var actualEndpointConfig endpointconfigv1.EndpointConfig
+	// TODO need to support pagination. See modelReconciler.getActualModelsForHostingDeployment
+	endpointConfigs := &endpointconfigv1.EndpointConfigList{}
+	if err := r.k8sClient.List(ctx, endpointConfigs, ownershipLabelSelector); err != nil {
+		return nil, errors.Wrap(err, "Unable to get existing EndpointConfigs")
+	}
 
-	if err := r.k8sClient.Get(ctx, key, &actualEndpointConfig); err != nil {
-		if apierrs.IsNotFound(err) {
-			return nil, nil
-		} else {
-			return nil, errors.Wrapf(err, "Unable to get existing endpoint config '%s'", key)
-		}
+	actualEndpointConfigs := map[string]*endpointconfigv1.EndpointConfig{}
+	for i, endpointConfig := range endpointConfigs.Items {
+		actualEndpointConfigs[endpointConfig.ObjectMeta.Name] = &endpointConfigs.Items[i]
 	}
 
-	return &actualEndpointConfig, nil
+	return actualEndpointConfigs, nil
 }
 
 // Determine the action necessary to bring actual state to desired state.
-func (r *endpointConfigReconciler) determineActionForEndpointConfig(desired, actual *endpointconfigv1.EndpointConfig) ReconcileAction {
+func (r *endpointConfigReconciler) determineActionForEndpointConfig(desired *endpointconfigv1.EndpointConfig, actualEndpointConfigs map[string]*endpointconfigv1.EndpointConfig) map[ReconcileAction]map[string]*endpointconfigv1.EndpointConfig {
 
-	if desired == nil {
-		if actual != nil {
-			return NeedsDelete
-		}
-		return NeedsNoop
+	// Put desired into a map even though it is singular.
+	// This makes the following logic closer to models and easier to follow.
+	desiredEndpointConfigs := map[string]*endpointconfigv1.EndpointConfig{}
+	if desired != nil {
+		desiredEndpointConfigs[desired.ObjectMeta.GetName()] = desired
 	}
 
-	if actual == nil {
-		return NeedsCreate
+	actions := map[ReconcileAction]map[string]*endpointconfigv1.EndpointConfig{
+		NeedsCreate: map[string]*endpointconfigv1.EndpointConfig{},
+		NeedsDelete: map[string]*endpointconfigv1.EndpointConfig{},
+		NeedsNoop:   map[string]*endpointconfigv1.EndpointConfig{},
+		NeedsUpdate: map[string]*endpointconfigv1.EndpointConfig{},
+	}
+	visited := map[string]*endpointconfigv1.EndpointConfig{}
+
+	for name, desiredEndpointConfig := range desiredEndpointConfigs {
+		if actualEndpointConfig, exists := actualEndpointConfigs[name]; exists {
+			if reflect.DeepEqual(desiredEndpointConfig.Spec, actualEndpointConfig.Spec) {
+				actions[NeedsNoop][name] = desiredEndpointConfig
+			} else {
+				targetEndpointConfig := actualEndpointConfigs[name].DeepCopy()
+				targetEndpointConfig.Spec = desiredEndpointConfig.Spec
+				actions[NeedsUpdate][name] = targetEndpointConfig
+			}
+		} else {
+			actions[NeedsCreate][name] = desiredEndpointConfig
+		}
+
+		visited[name] = desiredEndpointConfig
 	}
 
-	if reflect.DeepEqual(desired.Spec, actual.Spec) {
-		return NeedsNoop
+	for name, actualEndpointConfig := range actualEndpointConfigs {
+		if _, visited := visited[name]; visited {
+			continue
+		}
+		actions[NeedsDelete][name] = actualEndpointConfig
 	}
 
-	return NeedsUpdate
+	return actions
 }
 
 // Get the SageMaker EndpointConfig name from the status of the Kubernetes EndpointConfig.
@@ -261,16 +312,16 @@ func (r *endpointConfigReconciler) determineActionForEndpointConfig(desired, act
 func (r *endpointConfigReconciler) GetSageMakerEndpointConfigName(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) (string, error) {
 
 	var err error
-	var actualEndpointConfig *endpointconfigv1.EndpointConfig
-	if actualEndpointConfig, err = r.getActualEndpointConfigForHostingDeployment(ctx, desiredDeployment); err != nil {
-		return "", errors.Wrap(err, "Unable to get actual endpoint config")
+	var desiredEndpointConfig *endpointconfigv1.EndpointConfig
+	if desiredEndpointConfig, err = r.extractDesiredEndpointConfigFromHostingDeployment(ctx, desiredDeployment); err != nil {
+		return "", errors.Wrap(err, "Unable to interpret HostingDeployment endpoint config")
 	}
 
-	if actualEndpointConfig == nil {
+	if desiredEndpointConfig == nil {
 		return "", nil
 	}
 
-	if name, err := r.getSageMakerEndpointConfigName(ctx, actualEndpointConfig); err != nil {
+	if name, err := r.getSageMakerEndpointConfigName(ctx, desiredEndpointConfig); err != nil {
 		return "", errors.Wrap(err, "Unable to get SageMaker EndpointConfig name")
 	} else {
 		return name, nil
diff --git a/sagemaker-k8s-operator/controllers/hosting/endpointconfig_reconciler_test.go b/sagemaker-k8s-operator/controllers/hosting/endpointconfig_reconciler_test.go
index 3a714bb..070db8b 100644
--- a/sagemaker-k8s-operator/controllers/hosting/endpointconfig_reconciler_test.go
+++ b/sagemaker-k8s-operator/controllers/hosting/endpointconfig_reconciler_test.go
@@ -59,7 +59,7 @@ var _ = Describe("EndpointConfigReconciler.Reconcile", func() {
 			},
 		}
 
-		err := reconciler.Reconcile(context.Background(), &desired)
+		err := reconciler.Reconcile(context.Background(), &desired, true)
 
 		Expect(err).To(HaveOccurred())
 		Expect(err.Error()).To(ContainSubstring("ProductionVariant has nil VariantName"))
@@ -75,7 +75,7 @@ var _ = Describe("EndpointConfigReconciler.Reconcile", func() {
 			},
 		}
 
-		err := reconciler.Reconcile(context.Background(), &desired)
+		err := reconciler.Reconcile(context.Background(), &desired, true)
 
 		Expect(err).To(HaveOccurred())
 		Expect(err.Error()).To(ContainSubstring("ProductionVariant"))
@@ -89,7 +89,7 @@ var _ = Describe("EndpointConfigReconciler.Reconcile", func() {
 		})
 
 		It("Returns error if unable to get K8s EndpointConfig", func() {
-			err := reconciler.Reconcile(context.Background(), &desired)
+			err := reconciler.Reconcile(context.Background(), &desired, true)
 
 			Expect(err).To(HaveOccurred())
 			Expect(err.Error()).To(ContainSubstring("Unable to resolve SageMaker model name for model"))
@@ -130,7 +130,7 @@ var _ = Describe("EndpointConfigReconciler.Reconcile", func() {
 		reconciler = NewEndpointConfigReconciler(FailTestOnCreateK8sClient{
 			ActualClient: k8sClient,
 		}, ctrl.Log)
-		err = reconciler.Reconcile(context.Background(), &desired)
+		err = reconciler.Reconcile(context.Background(), &desired, true)
 
 		Expect(err).ToNot(HaveOccurred())
 	})
@@ -154,7 +154,7 @@ var _ = Describe("EndpointConfigReconciler.Reconcile", func() {
 
 		It("Returns error if unable to create k8s EndpointConfig", func() {
 			Skip("Fix me later")
-			err := reconciler.Reconcile(context.Background(), &desired)
+			err := reconciler.Reconcile(context.Background(), &desired, true)
 
 			Expect(err).To(HaveOccurred())
 			Expect(err.Error()).To(ContainSubstring("Unable to create Kubernetes EndpointConfig"))
@@ -190,7 +190,7 @@ var _ = Describe("EndpointConfigReconciler.Reconcile", func() {
 			modelNamespacedName := GetKubernetesModelNamespacedName(modelName, desired)
 			Expect(createCreatedModelWithAnySageMakerName(modelNamespacedName, desired)).ToNot(HaveOccurred())
 
-			reconciler.Reconcile(context.Background(), &desired)
+			reconciler.Reconcile(context.Background(), &desired, true)
 		})
 
 		AfterEach(func() {
@@ -271,7 +271,7 @@ var _ = Describe("Delete EndpointConfigReconciler.Reconcile", func() {
 		modelNamespacedName := GetKubernetesModelNamespacedName(modelName, desired)
 		Expect(createCreatedModelWithAnySageMakerName(modelNamespacedName, desired)).ToNot(HaveOccurred())
 
-		reconciler.Reconcile(context.Background(), &desired)
+		reconciler.Reconcile(context.Background(), &desired, true)
 
 		var endpointConfig endpointconfigv1.EndpointConfig
 		err := k8sClient.Get(context.Background(), expectedEndpointConfigNamespacedName, &endpointConfig)
@@ -377,7 +377,7 @@ var _ = Describe("Update EndpointConfigReconciler.Reconcile", func() {
 		updated := desired.DeepCopy()
 		updated.Spec.ProductionVariants[0].InitialVariantWeight = &newWeight
 
-		err := reconciler.Reconcile(context.Background(), updated)
+		err := reconciler.Reconcile(context.Background(), updated, true)
 		Expect(err).ToNot(HaveOccurred())
 
 		var endpointConfig endpointconfigv1.EndpointConfig
@@ -402,7 +402,7 @@ func createCreatedModelWithSageMakerName(namespacedName types.NamespacedName, de
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      namespacedName.Name,
 			Namespace: namespacedName.Namespace,
-			Labels:    GetModelOwnershipLabelsForHostingDeployment(deployment),
+			Labels:    GetResourceOwnershipLabelsForHostingDeployment(deployment),
 		},
 		Spec: modelv1.ModelSpec{
 			ExecutionRoleArn: ToStringPtr("xxx"),
@@ -494,3 +494,20 @@ func createHostingDeployment(k8sName, k8sNamespace string) hostingv1.HostingDepl
 		},
 	}
 }
+
+func updateEndpointConfigStatus(namespacedName types.NamespacedName, status, sageMakerEndpointConfigName string) error {
+	var endpointconfig endpointconfigv1.EndpointConfig
+	err := k8sClient.Get(context.Background(), namespacedName, &endpointconfig)
+	if err != nil {
+		return err
+	}
+
+	endpointconfig.Status.Status = status
+	endpointconfig.Status.SageMakerEndpointConfigName = sageMakerEndpointConfigName
+	err = k8sClient.Status().Update(context.Background(), &endpointconfig)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
diff --git a/sagemaker-k8s-operator/controllers/hosting/hostingdeployment_controller.go b/sagemaker-k8s-operator/controllers/hosting/hostingdeployment_controller.go
index 839d2bb..4a3d1d7 100644
--- a/sagemaker-k8s-operator/controllers/hosting/hostingdeployment_controller.go
+++ b/sagemaker-k8s-operator/controllers/hosting/hostingdeployment_controller.go
@@ -18,6 +18,8 @@ package hosting
 
 import (
 	"context"
+	"fmt"
+	"strings"
 	"time"
 
 	"github.com/go-logr/logr"
@@ -26,11 +28,13 @@ import (
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	ctrl "sigs.k8s.io/controller-runtime"
 	"sigs.k8s.io/controller-runtime/pkg/client"
+	"sigs.k8s.io/controller-runtime/pkg/predicate"
 
 	"github.com/aws/aws-sdk-go-v2/aws"
 	"github.com/aws/aws-sdk-go-v2/service/sagemaker"
 	"github.com/aws/aws-sdk-go-v2/service/sagemaker/sagemakeriface"
 
+	endpointconfigv1 "go.amzn.com/sagemaker/sagemaker-k8s-operator/api/v1/endpointconfig"
 	hostingv1 "go.amzn.com/sagemaker/sagemaker-k8s-operator/api/v1/hostingdeployment"
 	. "go.amzn.com/sagemaker/sagemaker-k8s-operator/controllers"
 	"go.amzn.com/sagemaker/sagemaker-k8s-operator/controllers/sdkutil"
@@ -38,9 +42,7 @@ import (
 )
 
 const (
-	PreparingEndpointStatus = "PreparingEndpoint"
-	DeletingEndpointStatus  = "DeletingEndpoint"
-	DeletedEndpointStatus   = "DeletedEndpoint"
+	ReconcilingEndpointStatus = "ReconcilingEndpoint"
 )
 
 // HostingDeploymentReconciler reconciles a HostingDeployment object
@@ -52,7 +54,6 @@ type HostingDeploymentReconciler struct {
 	awsConfigLoader                AwsConfigLoader
 	createModelReconciler          ModelReconcilerProvider
 	createEndpointConfigReconciler EndpointConfigReconcilerProvider
-	createEndpointReconciler       EndpointReconcilerProvider
 	createSageMakerClient          SageMakerClientProvider
 }
 
@@ -67,7 +68,6 @@ func NewHostingDeploymentReconciler(client client.Client, log logr.Logger, pollI
 		awsConfigLoader:                NewAwsConfigLoader(),
 		createModelReconciler:          NewModelReconciler,
 		createEndpointConfigReconciler: NewEndpointConfigReconciler,
-		createEndpointReconciler:       NewEndpointReconciler,
 	}
 }
 
@@ -75,6 +75,8 @@ func NewHostingDeploymentReconciler(client client.Client, log logr.Logger, pollI
 // +kubebuilder:rbac:groups=sagemaker.aws.amazon.com,resources=hostingdeployments/status,verbs=get;update;patch
 // +kubebuilder:rbac:groups=sagemaker.aws.amazon.com,resources=models,verbs=get;list;watch;create;update;patch;delete
 // +kubebuilder:rbac:groups=sagemaker.aws.amazon.com,resources=models/status,verbs=get;update;patch
+// +kubebuilder:rbac:groups=sagemaker.aws.amazon.com,resources=endpointconfigs,verbs=get;list;watch;create;update;patch;delete
+// +kubebuilder:rbac:groups=sagemaker.aws.amazon.com,resources=endpointconfigs/status,verbs=get;update;patch
 
 func (r *HostingDeploymentReconciler) Reconcile(req ctrl.Request) (ctrl.Result, error) {
 	ctx := reconcileRequestContext{
@@ -111,7 +113,6 @@ type reconcileRequestContext struct {
 	SageMakerClient          clientwrapper.SageMakerClientWrapper
 	ModelReconciler          ModelReconciler
 	EndpointConfigReconciler EndpointConfigReconciler
-	EndpointReconciler       EndpointReconciler
 
 	// The desired state of the HostingDeployment
 	Deployment *hostingv1.HostingDeployment
@@ -129,41 +130,36 @@ type reconcileRequestContext struct {
 	EndpointConfigName string
 }
 
+// Reconcile a HostingDeployment, creating, deleting or updating a SageMaker Endpoint as necessary.
+// SageMaker softly requires that corresponding EndpointConfig and Models exist during the lifetime of
+// an Endpoint. During Endpoint updates, both the existing set of EndpointConfig/Models and the new,
+// desired set of Endpoint/Models must exist for the entire duration of the update (~10 minutes x2).
+// This function thus creates necessary resources (EndpointConfig+Models) before creating the Endpoint,
+// and deletes the corresponding resources after the Endpoint is deleted.
+// Updates are a special case. Updates are only supported when the Endpoint is InService. When an update
+// occurs, this creates a new set of EndpointConfig/Model that lives alongside the old set of
+// EndpointConfig/Model for the duration of the endpoint update. Once the update is complete, and the
+// status is InService again, the old resources are deleted.
+//
+// See also:
+// UpdateEndpoint https://docs.aws.amazon.com/sagemaker/latest/dg/API_UpdateEndpoint.html
+// DescribeEndpoint https://docs.aws.amazon.com/sagemaker/latest/dg/API_DescribeEndpoint.html
 func (r *HostingDeploymentReconciler) reconcileHostingDeployment(ctx reconcileRequestContext) error {
 
-	ctx.EndpointName = GetSageMakerEndpointName(*ctx.Deployment)
-	r.Log.Info("SageMaker EndpointName", "name", ctx.EndpointName)
-
-	// TODO add SageMaker endpoint to spec.
-	sageMakerEndpoint := ""
-	awsConfig, err := r.awsConfigLoader.LoadAwsConfigWithOverrides(*ctx.Deployment.Spec.Region, &sageMakerEndpoint)
-	if err != nil {
-		ctx.Log.Error(err, "Error loading AWS config")
-		return err
-	}
-
-	ctx.SageMakerClient = clientwrapper.NewSageMakerClientWrapper(r.createSageMakerClient(awsConfig))
-	ctx.Log.Info("Loaded AWS config")
-	ctx.ModelReconciler = r.createModelReconciler(r, ctx.Log)
-	ctx.EndpointConfigReconciler = r.createEndpointConfigReconciler(r, ctx.Log)
-	ctx.EndpointReconciler = r.createEndpointReconciler(r, ctx.Log, ctx.SageMakerClient)
-
-	return r.reconcile(ctx)
-
-}
-
-// Reconcile HostingDeployments
-func (r *HostingDeploymentReconciler) reconcile(ctx reconcileRequestContext) error {
-
 	var err error
+	// Set first-touch status.
 	if ctx.Deployment.Status.EndpointStatus == "" {
 		if err = r.updateStatus(ctx, InitializingJobStatus); err != nil {
 			return err
 		}
 	}
 
+	if err = r.initializeContext(&ctx); err != nil {
+		return r.updateStatusAndReturnError(ctx, string(sagemaker.EndpointStatusFailed), errors.Wrap(err, "Unable to initialize operator"))
+	}
+
 	// Add finalizer if it's not marked for deletion.
-	if ctx.Deployment.ObjectMeta.GetDeletionTimestamp().IsZero() {
+	if !HasDeletionTimestamp(ctx.Deployment.ObjectMeta) {
 		if !ContainsString(ctx.Deployment.ObjectMeta.GetFinalizers(), SageMakerResourceFinalizerName) {
 			ctx.Deployment.ObjectMeta.Finalizers = append(ctx.Deployment.ObjectMeta.Finalizers, SageMakerResourceFinalizerName)
 			if err := r.Update(ctx, ctx.Deployment); err != nil {
@@ -172,91 +168,252 @@ func (r *HostingDeploymentReconciler) reconcile(ctx reconcileRequestContext) err
 			ctx.Log.Info("Finalizer added")
 		}
 	}
+
+	// Get the EndpointConfigName so that status updates can show it.
+	// If there is an error, ignore it.
+	if ctx.EndpointConfigName, err = ctx.EndpointConfigReconciler.GetSageMakerEndpointConfigName(ctx, ctx.Deployment); err != nil {
+		r.Log.Info("Unable to get EndpointConfigName", "err", err)
+	}
+
+	// Get the SageMaker model names so that status updates can show them.
+	// If there is an error, ignore it.
+	if ctx.ModelNames, err = ctx.ModelReconciler.GetSageMakerModelNames(ctx, ctx.Deployment); err != nil {
+		r.Log.Info("Unable to get model names", "err", err)
+	}
+
 	// Get the EndpointDescription from SageMaker.
 	if ctx.EndpointDescription, err = ctx.SageMakerClient.DescribeEndpoint(ctx, ctx.EndpointName); err != nil {
-		reconcileErr := errors.Wrap(err, "Unable to describe SageMaker endpoint")
-		if err = r.updateStatusWithAdditional(ctx, PreparingEndpointStatus, reconcileErr.Error()); err != nil {
-			return err
+		return r.updateStatusAndReturnError(ctx, ReconcilingEndpointStatus, errors.Wrap(err, "Unable to describe SageMaker endpoint"))
+	}
+
+	// The Endpoint does not exist. If the HostingDeployment needs to be deleted, then delete.
+	// Otherwise, create the Endpoint.
+	if ctx.EndpointDescription == nil {
+
+		if HasDeletionTimestamp(ctx.Deployment.ObjectMeta) {
+			return r.cleanupAndRemoveFinalizer(ctx)
+		}
+
+		if err = r.createEndpoint(ctx); err != nil {
+			return r.updateStatusAndReturnError(ctx, ReconcilingEndpointStatus, errors.Wrap(err, "Unable to create Endpoint"))
 		}
 
-		return reconcileErr
+		// Get description and continue
+		if ctx.EndpointDescription, err = ctx.SageMakerClient.DescribeEndpoint(ctx, ctx.EndpointName); err != nil {
+			return r.updateStatusAndReturnError(ctx, ReconcilingEndpointStatus, errors.Wrap(err, "Unable to describe SageMaker endpoint"))
+		}
 	}
 
-	// Reconcile Models.
-	if err = ctx.ModelReconciler.Reconcile(ctx, ctx.Deployment); err != nil {
+	// Updates and deletions are only supported in SageMaker when the Endpoint is "InService" (update or deletion) or "Failed" (only deletion).
+	// Thus, gate the updates/deletes according to status.
+	switch ctx.EndpointDescription.EndpointStatus {
+	case sagemaker.EndpointStatusInService:
 
-		reconcileErr := errors.Wrap(err, "Unable to reconcile models")
-		if err = r.updateStatusWithAdditional(ctx, PreparingEndpointStatus, reconcileErr.Error()); err != nil {
-			return err
+		// Only do updates if the object is not marked as deleted.
+		if !HasDeletionTimestamp(ctx.Deployment.ObjectMeta) {
+			if err = r.handleUpdates(ctx); err != nil {
+				return r.updateStatusAndReturnError(ctx, ReconcilingEndpointStatus, errors.Wrap(err, "Unable to update SageMaker endpoint"))
+			}
 		}
 
-		return reconcileErr
+		// Handle deletion by falling through.
+		fallthrough
+	case sagemaker.EndpointStatusFailed:
+		if HasDeletionTimestamp(ctx.Deployment.ObjectMeta) {
+			if _, err := ctx.SageMakerClient.DeleteEndpoint(ctx, &ctx.EndpointName); err != nil {
+				return r.updateStatusAndReturnError(ctx, ReconcilingEndpointStatus, errors.Wrap(err, "Unable to delete Endpoint"))
+			}
+		}
+		break
+	case sagemaker.EndpointStatusCreating:
+		fallthrough
+	case sagemaker.EndpointStatusDeleting:
+		fallthrough
+	case sagemaker.EndpointStatusOutOfService:
+		fallthrough
+	case sagemaker.EndpointStatusRollingBack:
+		fallthrough
+	case sagemaker.EndpointStatusSystemUpdating:
+		fallthrough
+	case sagemaker.EndpointStatusUpdating:
+		// The status will be updated after the switch statement.
+		r.Log.Info("Noop action, endpoint status does not allow modifications", "status", ctx.EndpointDescription.EndpointStatus)
 	}
 
-	if ctx.ModelNames, err = ctx.ModelReconciler.GetSageMakerModelNames(ctx, ctx.Deployment); err != nil {
-		ctx.Log.Info("Unable to get model names", "err", err)
+	status := string(ctx.EndpointDescription.EndpointStatus)
+
+	// Present to the user that the endpoint is being deleted after they delete the hosting deployment.
+	if HasDeletionTimestamp(ctx.Deployment.ObjectMeta) && ctx.EndpointDescription.EndpointStatus != sagemaker.EndpointStatusDeleting {
+		status = string(sagemaker.EndpointStatusDeleting)
+	}
+
+	if err = r.updateStatus(ctx, status); err != nil {
+		return err
 	}
 
-	// Reconcile EndpointConfigs.
-	if err = ctx.EndpointConfigReconciler.Reconcile(ctx, ctx.Deployment); err != nil {
+	return nil
+}
 
-		reconcileErr := errors.Wrap(err, "Unable to reconcile EndpointConfig")
-		if err = r.updateStatusWithAdditional(ctx, PreparingEndpointStatus, reconcileErr.Error()); err != nil {
-			return err
-		}
+// Start an Endpoint update. If the HostingDeployment spec was updated, this will create a new
+// set of models and endpointconfigs in SageMaker. If the endpoint's config name is different than
+// the new config name, then invoke UpdateEndpoint.
+// If no update is necessary, this cleans up unused resources (like those from a previously finished update).
+// TODO Currently if a user edits the HostingDeployment (which causes an error), then reverts their bad edit, an update will be triggered.
+// This is because the updates are determined by a change in generation number. We should ignore updates when the endpoint config is deep equal.
+func (r *HostingDeploymentReconciler) handleUpdates(ctx reconcileRequestContext) error {
+	var err error
 
-		return reconcileErr
+	// If the specs changed, then this will create new models and endpoint configs.
+	if err = r.reconcileEndpointResources(ctx, false); err != nil {
+		return errors.Wrap(err, "Unable to reconcile endpoint resources")
 	}
 
+	// Get the desired endpoint config name.
 	if ctx.EndpointConfigName, err = ctx.EndpointConfigReconciler.GetSageMakerEndpointConfigName(ctx, ctx.Deployment); err != nil {
-		ctx.Log.Info("Unable to get endpoint config name", "err", err)
+		return errors.Wrap(err, "Unable to get SageMaker EndpointConfigName for endpoint")
 	}
 
-	// Reconcile Endpoints.
-	if err = ctx.EndpointReconciler.Reconcile(ctx, ctx.Deployment, ctx.EndpointDescription); err != nil {
+	if ctx.EndpointConfigName == "" {
+		return fmt.Errorf("Unable to get SageMaker EndpointConfigName for endpoint")
+	}
 
-		reconcileErr := errors.Wrap(err, "Unable to reconcile Endpoint")
-		if err = r.updateStatusWithAdditional(ctx, PreparingEndpointStatus, reconcileErr.Error()); err != nil {
-			return err
-		}
+	// If the desired endpoint config name does not equal the actual endpoint config name, we need to call UpdateEndpoint.
+	if *ctx.EndpointDescription.EndpointConfigName != ctx.EndpointConfigName {
+		r.Log.Info("Endpoint needs update", "name", ctx.EndpointName, "config name", ctx.EndpointConfigName)
 
-		return reconcileErr
-	}
+		var output *sagemaker.UpdateEndpointOutput
+		if output, err = ctx.SageMakerClient.UpdateEndpoint(ctx, ctx.EndpointName, ctx.EndpointConfigName); err != nil {
+			return errors.Wrap(err, "Unable to update Endpoint")
+		}
 
-	var status string
-	// If not mark for deletion
-	if ctx.Deployment.ObjectMeta.GetDeletionTimestamp().IsZero() {
-		// If the SageMaker endpoint has been created, update the status with the new information.
-		if ctx.EndpointDescription != nil {
-			status = string(ctx.EndpointDescription.EndpointStatus)
-		} else {
-			status = PreparingEndpointStatus
+		// If the endpoint doesn't exist.
+		if output == nil {
+			return fmt.Errorf("Unable to update Endpoint: Endpoint not found")
 		}
 	} else {
-		// If SageMaker endpoint exists
-		if ctx.EndpointDescription != nil {
-			status = string(ctx.EndpointDescription.EndpointStatus)
-		} else {
-			status = DeletedEndpointStatus
+		r.Log.Info("Endpoint up to date")
+
+		// Clean up from previous update.
+		if err = r.reconcileEndpointResources(ctx, true); err != nil {
+			return errors.Wrap(err, "Unable to reconcile endpoint resources")
 		}
 	}
 
-	// Update the status for endpoint
-	if err = r.updateStatus(ctx, status); err != nil {
-		return err
+	return nil
+}
+
+// Create models and endpoint configs in SageMaker, then create the Endpoint.
+func (r *HostingDeploymentReconciler) createEndpoint(ctx reconcileRequestContext) error {
+	var err error
+	if err = r.reconcileEndpointResources(ctx, false); err != nil {
+		return errors.Wrap(err, "Unable to reconcile Endpoint resources")
+	}
+
+	var createEndpointInput *sagemaker.CreateEndpointInput
+	if createEndpointInput, err = r.createCreateEndpointInput(ctx); err != nil {
+		return errors.Wrap(err, "Unable to create CreateEndpointInput")
+	}
+
+	r.Log.Info("Create endpoint", "input", createEndpointInput)
+
+	if _, err := ctx.SageMakerClient.CreateEndpoint(ctx, createEndpointInput); err != nil {
+		return errors.Wrap(err, "Unable to delete Endpoint")
+	}
+
+	return nil
+}
+
+// Clean up all models and endpoints, then remove the HostingDeployment finalizer.
+func (r *HostingDeploymentReconciler) cleanupAndRemoveFinalizer(ctx reconcileRequestContext) error {
+	var err error
+	if err = r.reconcileEndpointResources(ctx, true); err != nil {
+		return r.updateStatusAndReturnError(ctx, ReconcilingEndpointStatus, errors.Wrap(err, "Unable to clean up HostingDeployment"))
 	}
 
-	// Remove finalizer if it's marked for deletion
 	if !ctx.Deployment.ObjectMeta.GetDeletionTimestamp().IsZero() {
 		ctx.Deployment.ObjectMeta.Finalizers = RemoveString(ctx.Deployment.ObjectMeta.Finalizers, SageMakerResourceFinalizerName)
-		if err := r.Update(ctx, ctx.Deployment); err != nil {
+		if err = r.Update(ctx, ctx.Deployment); err != nil {
 			return errors.Wrap(err, "Failed to remove finalizer")
 		}
 		ctx.Log.Info("Finalizer has been removed")
 	}
+
+	return nil
+}
+
+// Initialize fields on the context object which will be used later.
+func (r *HostingDeploymentReconciler) initializeContext(ctx *reconcileRequestContext) error {
+	ctx.EndpointName = GetSageMakerEndpointName(*ctx.Deployment)
+	r.Log.Info("SageMaker EndpointName", "name", ctx.EndpointName)
+
+	// TODO add SageMaker endpoint to spec.
+	sageMakerEndpoint := ""
+	awsConfig, err := r.awsConfigLoader.LoadAwsConfigWithOverrides(*ctx.Deployment.Spec.Region, &sageMakerEndpoint)
+	if err != nil {
+		ctx.Log.Error(err, "Error loading AWS config")
+		return err
+	}
+
+	ctx.SageMakerClient = clientwrapper.NewSageMakerClientWrapper(r.createSageMakerClient(awsConfig))
+	ctx.Log.Info("Loaded AWS config")
+	ctx.ModelReconciler = r.createModelReconciler(r, ctx.Log)
+	ctx.EndpointConfigReconciler = r.createEndpointConfigReconciler(r, ctx.Log)
+
 	return nil
 }
 
+// Reconcile resources necessary to create an Endpoint. This includes Models and EndpointConfigs. If shouldDeleteUnusedResources is true,
+// then clean up all resources that are unused. This should be false when an update is in-progress, as SageMaker requires both sets of
+// models/endpoint configs exist until the update is finished.
+func (r *HostingDeploymentReconciler) reconcileEndpointResources(ctx reconcileRequestContext, shouldDeleteUnusedResources bool) error {
+	r.Log.Info("Reconcile endpoint resources", "shouldDeleteUnusedResources", shouldDeleteUnusedResources)
+
+	// TODO This should create models, then endpoint configs when creating, and reverse the order when deleting.
+	if err := ctx.ModelReconciler.Reconcile(ctx, ctx.Deployment, shouldDeleteUnusedResources); err != nil {
+		return r.updateStatusAndReturnError(ctx, ReconcilingEndpointStatus, errors.Wrap(err, "Unable to reconcile models"))
+	}
+
+	if err := ctx.EndpointConfigReconciler.Reconcile(ctx, ctx.Deployment, shouldDeleteUnusedResources); err != nil {
+		return r.updateStatusAndReturnError(ctx, ReconcilingEndpointStatus, errors.Wrap(err, "Unable to reconcile EndpointConfigs"))
+	}
+	return nil
+}
+
+// Create CreateEndpointInput.
+func (r *HostingDeploymentReconciler) createCreateEndpointInput(ctx reconcileRequestContext) (*sagemaker.CreateEndpointInput, error) {
+	r.Log.Info("Create CreateEndpointInput")
+
+	namespacedName := GetKubernetesEndpointConfigNamespacedName(*ctx.Deployment)
+
+	var endpointConfig endpointconfigv1.EndpointConfig
+	if err := r.Client.Get(ctx, namespacedName, &endpointConfig); err != nil {
+		return nil, errors.Wrapf(err, "Unable to resolve SageMaker EndpointConfig name for EndpointConfig '%s'", namespacedName)
+	}
+
+	if endpointConfig.Status.SageMakerEndpointConfigName == "" {
+		return nil, fmt.Errorf("EndpointConfig '%s' does not have a SageMakerEndpointConfigName", namespacedName)
+	}
+
+	endpointName := GetSageMakerEndpointName(*ctx.Deployment)
+
+	createInput := &sagemaker.CreateEndpointInput{
+		EndpointConfigName: &endpointConfig.Status.SageMakerEndpointConfigName,
+		EndpointName:       &endpointName,
+		Tags:               sdkutil.ConvertTagSliceToSageMakerTagSlice(ctx.Deployment.Spec.Tags),
+	}
+
+	return createInput, nil
+}
+
+// Helper method to update the status with the error message and status. If there was an error updating the status, return
+// that error instead.
+func (r *HostingDeploymentReconciler) updateStatusAndReturnError(ctx reconcileRequestContext, status string, reconcileErr error) error {
+	if err := r.updateStatusWithAdditional(ctx, status, reconcileErr.Error()); err != nil {
+		return errors.Wrapf(reconcileErr, "Unable to update status with error. Status failure was caused by: '%s'", err.Error())
+	}
+	return reconcileErr
+}
+
 // Update the status and other informational fields.
 // Returns an error if there was a failure to update.
 func (r *HostingDeploymentReconciler) updateStatus(ctx reconcileRequestContext, endpointStatus string) error {
@@ -282,6 +439,8 @@ func (r *HostingDeploymentReconciler) updateStatusWithAdditional(ctx reconcileRe
 		deploymentStatus.LastModifiedTime = convertTimeOrDefault(endpoint.LastModifiedTime, nil)
 		deploymentStatus.CreationTime = convertTimeOrDefault(endpoint.CreationTime, nil)
 
+		// TODO The ProductionVariant retrieved from SageMaker does not reflect updates (desiredInstanceCount does not change, even though it should).
+		// This might be a bug in how we're using SageMaker or a bug in SageMaker.
 		if converted, err := sdkutil.ConvertProductionVariantSummarySlice(endpoint.ProductionVariants); err != nil {
 			return errors.Wrap(err, "Unable to interpret ProductionVariant for status")
 		} else {
@@ -317,9 +476,22 @@ func convertTimeOrDefault(time *time.Time, defaultValue *metav1.Time) *metav1.Ti
 	return &converted
 }
 
-// TODO add code that ignores status, metadata updates.
+// Get the SageMaker Endpoint name given a HostingDeployment.
+func GetSageMakerEndpointName(desiredDeployment hostingv1.HostingDeployment) string {
+	SMMaxLen := 63
+	name := desiredDeployment.ObjectMeta.GetName()
+	uid := strings.Replace(string(desiredDeployment.ObjectMeta.GetUID()), "-", "", -1)
+	smEndpointName := name + "-" + uid
+	if len(smEndpointName) > SMMaxLen {
+		smEndpointName = name[:SMMaxLen-len(uid)-1] + "-" + uid
+	}
+	return smEndpointName
+}
+
 func (r *HostingDeploymentReconciler) SetupWithManager(mgr ctrl.Manager) error {
 	return ctrl.NewControllerManagedBy(mgr).
 		For(&hostingv1.HostingDeployment{}).
+		// Ignore status-only and metadata-only updates
+		WithEventFilter(predicate.GenerationChangedPredicate{}).
 		Complete(r)
 }
diff --git a/sagemaker-k8s-operator/controllers/hosting/hostingdeployment_controller_test.go b/sagemaker-k8s-operator/controllers/hosting/hostingdeployment_controller_test.go
index 13f0823..462f973 100644
--- a/sagemaker-k8s-operator/controllers/hosting/hostingdeployment_controller_test.go
+++ b/sagemaker-k8s-operator/controllers/hosting/hostingdeployment_controller_test.go
@@ -26,7 +26,6 @@ import (
 	. "github.com/onsi/gomega"
 
 	. "go.amzn.com/sagemaker/sagemaker-k8s-operator/controllers/controllertest"
-	"go.amzn.com/sagemaker/sagemaker-k8s-operator/controllers/sdkutil/clientwrapper"
 
 	"github.com/aws/aws-sdk-go-v2/service/sagemaker"
 	"github.com/aws/aws-sdk-go-v2/service/sagemaker/sagemakeriface"
@@ -54,7 +53,7 @@ var _ = Describe("Reconciling a HostingDeployment while failing to get the Kuber
 	})
 
 	It("should not requeue if the HostingDeployment does not exist", func() {
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, "1s")
 
 		request := CreateReconciliationRequest("non-existent-name", "namespace")
 
@@ -67,7 +66,7 @@ var _ = Describe("Reconciling a HostingDeployment while failing to get the Kuber
 
 	It("should requeue if there was an error", func() {
 		mockK8sClient := FailToGetK8sClient{}
-		controller := createReconciler(mockK8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(mockK8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, "1s")
 
 		request := CreateReconciliationRequest("non-existent-name", "namespace")
 
@@ -105,7 +104,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint does not exi
 		modelReconciler := mockModelReconciler{}
 		modelReconciler.DesiredDeployments = &List{}
 
-		controller := createReconciler(k8sClient, sageMakerClient, &modelReconciler, &mockEndpointConfigReconciler{}, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &modelReconciler, &mockEndpointConfigReconciler{}, "1s")
 		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
 
 		controller.Reconcile(request)
@@ -121,7 +120,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint does not exi
 		modelReconciler.ReconcileReturnValues = &List{}
 		modelReconciler.ReconcileReturnValues.PushBack(fmt.Errorf("mock error"))
 
-		controller := createReconciler(k8sClient, sageMakerClient, &modelReconciler, &mockEndpointConfigReconciler{}, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &modelReconciler, &mockEndpointConfigReconciler{}, "1s")
 		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
 
 		result, err := controller.Reconcile(request)
@@ -138,7 +137,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint does not exi
 		modelReconciler.ReconcileReturnValues = &List{}
 		modelReconciler.ReconcileReturnValues.PushBack(fmt.Errorf(errorMessage))
 
-		controller := createReconciler(k8sClient, sageMakerClient, &modelReconciler, &mockEndpointConfigReconciler{}, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &modelReconciler, &mockEndpointConfigReconciler{}, "1s")
 		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
 
 		_, err := controller.Reconcile(request)
@@ -159,7 +158,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint does not exi
 		endpointConfigReconciler := mockEndpointConfigReconciler{}
 		endpointConfigReconciler.DesiredDeployments = &List{}
 
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &endpointConfigReconciler, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &endpointConfigReconciler, "1s")
 		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
 
 		controller.Reconcile(request)
@@ -175,7 +174,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint does not exi
 		endpointConfigReconciler.ReconcileReturnValues = &List{}
 		endpointConfigReconciler.ReconcileReturnValues.PushBack(fmt.Errorf("mock error"))
 
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &endpointConfigReconciler, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &endpointConfigReconciler, "1s")
 		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
 
 		result, err := controller.Reconcile(request)
@@ -192,67 +191,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint does not exi
 		endpointConfigReconciler.ReconcileReturnValues = &List{}
 		endpointConfigReconciler.ReconcileReturnValues.PushBack(fmt.Errorf(errorMessage))
 
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &endpointConfigReconciler, &mockEndpointReconciler{}, "1s")
-		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
-
-		_, err := controller.Reconcile(request)
-		Expect(err).ToNot(HaveOccurred())
-
-		var updatedDeployment hostingv1.HostingDeployment
-		err = k8sClient.Get(context.Background(), types.NamespacedName{
-			Namespace: deployment.ObjectMeta.Namespace,
-			Name:      deployment.ObjectMeta.Name,
-		}, &updatedDeployment)
-		Expect(err).ToNot(HaveOccurred())
-
-		Expect(updatedDeployment.Status.Additional).To(ContainSubstring(errorMessage))
-	})
-
-	It("should call EndpointReconciler.Reconcile with correct parameters", func() {
-		Skip("Fix me later")
-		endpointReconciler := mockEndpointReconciler{}
-		endpointReconciler.DesiredDeployments = &List{}
-		endpointReconciler.ActualDeployments = &List{}
-
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, &endpointReconciler, "1s")
-		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
-
-		controller.Reconcile(request)
-
-		Expect(endpointReconciler.DesiredDeployments.Len()).To(Equal(1))
-		desiredDeployment := endpointReconciler.DesiredDeployments.Front().Value.(*hostingv1.HostingDeployment)
-		Expect(desiredDeployment.Spec).To(Equal(deployment.Spec))
-
-		// Since the endpoint does not exist, we check that the reconciler received an empty actual state.
-		Expect(endpointReconciler.ActualDeployments.Len()).To(Equal(1))
-		actualDeployment := endpointReconciler.ActualDeployments.Front().Value.(*sagemaker.DescribeEndpointOutput)
-		Expect(actualDeployment).To(BeNil())
-	})
-
-	It("should requeue if EndpointReconciler.Reconcile failed", func() {
-		Skip("Fix me later")
-		endpointReconciler := mockEndpointReconciler{}
-		endpointReconciler.ReconcileReturnValues = &List{}
-		endpointReconciler.ReconcileReturnValues.PushBack(fmt.Errorf("mock error"))
-
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, &endpointReconciler, "1s")
-		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
-
-		result, err := controller.Reconcile(request)
-
-		Expect(err).ToNot(HaveOccurred())
-		Expect(result.Requeue).To(Equal(true))
-		Expect(endpointReconciler.ReconcileReturnValues.Len()).To(Equal(0))
-	})
-
-	It("should correctly update the status if EndpointReconciler.Reconcile failed", func() {
-		Skip("Fix me later")
-		errorMessage := "mock error"
-		endpointReconciler := mockEndpointReconciler{}
-		endpointReconciler.ReconcileReturnValues = &List{}
-		endpointReconciler.ReconcileReturnValues.PushBack(fmt.Errorf(errorMessage))
-
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, &endpointReconciler, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &endpointConfigReconciler, "1s")
 		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
 
 		_, err := controller.Reconcile(request)
@@ -270,7 +209,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint does not exi
 
 	It("should update the status", func() {
 		Skip("Fix me later")
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, "1s")
 		request := CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace)
 
 		_, err := controller.Reconcile(request)
@@ -283,7 +222,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint does not exi
 		}, &updatedDeployment)
 		Expect(err).ToNot(HaveOccurred())
 
-		Expect(updatedDeployment.Status.EndpointStatus).To(Equal(PreparingEndpointStatus))
+		Expect(updatedDeployment.Status.EndpointStatus).To(Equal(ReconcilingEndpointStatus))
 	})
 })
 
@@ -321,7 +260,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint exists", fun
 			}).
 			Build()
 
-		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, &mockEndpointReconciler{}, "1s")
+		controller := createReconciler(k8sClient, sageMakerClient, &mockModelReconciler{}, &mockEndpointConfigReconciler{}, "1s")
 		controller.Reconcile(CreateReconciliationRequest(deployment.ObjectMeta.Name, deployment.ObjectMeta.Namespace))
 
 		var updatedDeployment hostingv1.HostingDeployment
@@ -341,7 +280,7 @@ var _ = Describe("Reconciling a HostingDeployment when the endpoint exists", fun
 
 })
 
-func createReconciler(k8sClient k8sclient.Client, sageMakerClient sagemakeriface.ClientAPI, modelReconciler ModelReconciler, endpointConfigReconciler EndpointConfigReconciler, endpointReconciler EndpointReconciler, pollIntervalStr string) HostingDeploymentReconciler {
+func createReconciler(k8sClient k8sclient.Client, sageMakerClient sagemakeriface.ClientAPI, modelReconciler ModelReconciler, endpointConfigReconciler EndpointConfigReconciler, pollIntervalStr string) HostingDeploymentReconciler {
 	pollInterval := ParseDurationOrFail(pollIntervalStr)
 
 	return HostingDeploymentReconciler{
@@ -352,7 +291,6 @@ func createReconciler(k8sClient k8sclient.Client, sageMakerClient sagemakeriface
 		awsConfigLoader:                CreateMockAwsConfigLoader(),
 		createModelReconciler:          createModelReconcilerProvider(modelReconciler),
 		createEndpointConfigReconciler: createEndpointConfigReconcilerProvider(endpointConfigReconciler),
-		createEndpointReconciler:       createEndpointReconcilerProvider(endpointReconciler),
 	}
 }
 
@@ -368,26 +306,6 @@ func createEndpointConfigReconcilerProvider(endpointConfigReconciler EndpointCon
 	}
 }
 
-func createEndpointReconcilerProvider(endpointReconciler EndpointReconciler) EndpointReconcilerProvider {
-	return func(_ client.Client, _ logr.Logger, _ clientwrapper.SageMakerClientWrapper) EndpointReconciler {
-		return endpointReconciler
-	}
-}
-
-// Mock implementation of EndpointReconciler.
-// This simply tracks invocations of Reconcile and the parameters it was called with.
-// Return values are configurable.
-type mockEndpointReconciler struct {
-	EndpointReconciler
-	subreconcilerCallTracker
-}
-
-// Mock implementation of Reconcile. This stores the parameters it was called with in the mock. It also will return a ReturnValue
-// in each invocation.
-func (r *mockEndpointReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, actualDeployment *sagemaker.DescribeEndpointOutput) error {
-	return r.TrackAll(desiredDeployment, actualDeployment)
-}
-
 // Mock implementation of EndpointConfigReconciler.
 // This simply tracks invocations of Reconcile and the parameters it was called with.
 // Return values are configurable.
@@ -398,7 +316,7 @@ type mockEndpointConfigReconciler struct {
 
 // Mock implementation of Reconcile. This stores the parameters it was called with in the mock. It also will return a ReturnValue
 // in each invocation.
-func (r *mockEndpointConfigReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) error {
+func (r *mockEndpointConfigReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, shouldDeleteUnusedResources bool) error {
 	return r.TrackOnlyDesiredDeployment(desiredDeployment)
 }
 
@@ -417,7 +335,7 @@ type mockModelReconciler struct {
 
 // Mock implementation of Reconcile. This stores the parameters it was called with in the mock. It also will return a ReturnValue
 // in each invocation.
-func (r *mockModelReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) error {
+func (r *mockModelReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, shouldDeletedUnusedModels bool) error {
 	return r.TrackOnlyDesiredDeployment(desiredDeployment)
 }
 
@@ -426,7 +344,7 @@ func (r *mockModelReconciler) GetSageMakerModelNames(ctx context.Context, desire
 	return map[string]string{}, nil
 }
 
-// Call tracker for sub reconcilers (ModelReconciler/EndpointConfigReconciler/EndpointReconciler).
+// Call tracker for sub reconcilers (ModelReconciler/EndpointConfigReconciler).
 // Common logic and variables are refactored into this common struct.
 // This simply tracks invocations of Reconcile and the parameters it was called with.
 // Return values are configurable.
diff --git a/sagemaker-k8s-operator/controllers/hosting/model_reconciler.go b/sagemaker-k8s-operator/controllers/hosting/model_reconciler.go
index 2e6fcc6..dc0b509 100644
--- a/sagemaker-k8s-operator/controllers/hosting/model_reconciler.go
+++ b/sagemaker-k8s-operator/controllers/hosting/model_reconciler.go
@@ -20,6 +20,7 @@ import (
 	"context"
 	"fmt"
 	"reflect"
+	"strconv"
 	"strings"
 
 	"github.com/go-logr/logr"
@@ -47,7 +48,7 @@ func NewModelReconciler(client client.Client, log logr.Logger) ModelReconciler {
 
 // Helper type that is responsible for reconciling models of an endpoint.
 type ModelReconciler interface {
-	Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) error
+	Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, shouldDeleteUnusedModels bool) error
 	GetSageMakerModelNames(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) (map[string]string, error)
 }
 
@@ -64,9 +65,10 @@ var _ ModelReconciler = (*modelReconciler)(nil)
 // If there are models that are desired but do not exist, create them.
 // If there are models that are not desired but exist, delete them.
 // This creates a modelv1.Model in Kubernetes before creating the model in SageMaker for idempotency.
+// The parameter shouldDeleteUnusedResources controls whether unnecessary endpoint configs are deleted. This is useful when updating Endpoints.
 //
 // Returns an error if any operation fails. The reconciliation should be retried if err is non-nil.
-func (r *modelReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) error {
+func (r *modelReconciler) Reconcile(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment, shouldDeleteUnusedModels bool) error {
 	r.log.Info("Reconciling models")
 
 	var err error
@@ -92,8 +94,12 @@ func (r *modelReconciler) Reconcile(ctx context.Context, desiredDeployment *host
 		return errors.Wrap(err, "Unable to create model(s)")
 	}
 
-	if err = r.reconcileModelsToDelete(ctx, modelsToDelete); err != nil {
-		return errors.Wrap(err, "Unable to delete model(s)")
+	if shouldDeleteUnusedModels {
+		if err = r.reconcileModelsToDelete(ctx, modelsToDelete); err != nil {
+			return errors.Wrap(err, "Unable to delete model(s)")
+		}
+	} else {
+		r.log.Info("Ignoring modelsToDelete because shouldDeleteUnusedModels=false", "shouldDeleteUnusedModels", shouldDeleteUnusedModels)
 	}
 
 	if err = r.reconcileModelsToUpdate(ctx, modelsToUpdate); err != nil {
@@ -168,7 +174,7 @@ func getModelNamesFromMap(m map[string]*modelv1.Model) []string {
 // This is necessary when the spec is updated and a model is completely deleted from the spec. In order
 // to delete the model in Kubernetes, the HostingDeployment controller needs to be able to list all
 // models that it created.
-func GetModelOwnershipLabelsForHostingDeployment(deployment hostingv1.HostingDeployment) map[string]string {
+func GetResourceOwnershipLabelsForHostingDeployment(deployment hostingv1.HostingDeployment) map[string]string {
 	typeName := reflect.TypeOf(deployment).Name()
 
 	return map[string]string{
@@ -180,7 +186,7 @@ func GetModelOwnershipLabelsForHostingDeployment(deployment hostingv1.HostingDep
 // Get models created for the desired deployment. This looks up existing models by HostingDeployment ownership labels.
 func (r *modelReconciler) getActualModelsForHostingDeployment(ctx context.Context, desiredDeployment *hostingv1.HostingDeployment) (map[string]*modelv1.Model, error) {
 
-	ownershipLabelSelector := client.MatchingLabels(GetModelOwnershipLabelsForHostingDeployment(*desiredDeployment))
+	ownershipLabelSelector := client.MatchingLabels(GetResourceOwnershipLabelsForHostingDeployment(*desiredDeployment))
 
 	// TODO need to support pagination.
 	// See https://github.com/kubernetes-sigs/controller-runtime/blob/6b91e8e65756b561525314771a913145d161aa14/pkg/client/options.go#L457-L461 for how to use limits and test.
@@ -289,7 +295,7 @@ func (r *modelReconciler) extractDesiredModelsFromHostingDeployment(deployment *
 
 		// Add labels to model that indicate which particular HostingDeployment
 		// owns it.
-		ownershipLabels := GetModelOwnershipLabelsForHostingDeployment(*deployment)
+		ownershipLabels := GetResourceOwnershipLabelsForHostingDeployment(*deployment)
 
 		k8sModel := &modelv1.Model{
 			ObjectMeta: metav1.ObjectMeta{
@@ -412,10 +418,13 @@ func (r *modelReconciler) getPrimaryContainerDefinition(model *commonv1.Model, c
 func GetKubernetesModelNamespacedName(modelName string, hostingDeployment hostingv1.HostingDeployment) types.NamespacedName {
 	k8sMaxLen := 253
 	uid := strings.Replace(string(hostingDeployment.ObjectMeta.GetUID()), "-", "", -1)
-	name := modelName + "-" + uid
+	generation := strconv.FormatInt(hostingDeployment.ObjectMeta.GetGeneration(), 10)
+
+	requiredPostfix := "-" + generation + "-" + uid
+	name := modelName + requiredPostfix
 
 	if len(name) > k8sMaxLen {
-		name = modelName[:k8sMaxLen-len(uid)-1] + "-" + uid
+		name = modelName[:k8sMaxLen-len(requiredPostfix)] + requiredPostfix
 	}
 
 	return types.NamespacedName{
diff --git a/sagemaker-k8s-operator/controllers/hosting/model_reconciler_test.go b/sagemaker-k8s-operator/controllers/hosting/model_reconciler_test.go
index 39ff3c5..0096f2c 100644
--- a/sagemaker-k8s-operator/controllers/hosting/model_reconciler_test.go
+++ b/sagemaker-k8s-operator/controllers/hosting/model_reconciler_test.go
@@ -70,7 +70,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 			},
 		}
 
-		err := reconciler.Reconcile(context.Background(), desired)
+		err := reconciler.Reconcile(context.Background(), desired, true)
 
 		Expect(err).To(HaveOccurred())
 	})
@@ -100,7 +100,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 			},
 		}
 
-		err := reconciler.Reconcile(context.Background(), desired)
+		err := reconciler.Reconcile(context.Background(), desired, true)
 
 		Expect(err).To(HaveOccurred())
 		Expect(err.Error()).To(ContainSubstring("Container hostnames must be unique."))
@@ -127,7 +127,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 			},
 		}
 
-		err := reconciler.Reconcile(context.Background(), desired)
+		err := reconciler.Reconcile(context.Background(), desired, true)
 
 		Expect(err).To(HaveOccurred())
 		Expect(err.Error()).To(ContainSubstring("Unable to determine primary container for model"))
@@ -163,7 +163,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 			},
 		}
 
-		err := reconciler.Reconcile(context.Background(), desired)
+		err := reconciler.Reconcile(context.Background(), desired, true)
 
 		Expect(err).To(HaveOccurred())
 		Expect(err.Error()).To(ContainSubstring("Missing container definition"))
@@ -198,7 +198,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 			},
 		}
 
-		err := reconciler.Reconcile(context.Background(), desired)
+		err := reconciler.Reconcile(context.Background(), desired, true)
 
 		Expect(err).To(HaveOccurred())
 		Expect(err.Error()).To(ContainSubstring("Unknown primary container"))
@@ -236,7 +236,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 				},
 			}
 
-			err := reconciler.Reconcile(context.Background(), desired)
+			err := reconciler.Reconcile(context.Background(), desired, true)
 
 			Expect(err).To(HaveOccurred())
 			Expect(err.Error()).To(ContainSubstring("Unable to get actual models"))
@@ -277,7 +277,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 				},
 			}
 
-			err := reconciler.Reconcile(context.Background(), desired)
+			err := reconciler.Reconcile(context.Background(), desired, true)
 
 			Expect(err).To(HaveOccurred())
 			Expect(err.Error()).To(ContainSubstring("Unable to create Kubernetes model"))
@@ -343,7 +343,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 
 			expectedModelName = GetKubernetesModelNamespacedName("model-name", *desired).Name
 
-			reconciler.Reconcile(context.Background(), desired)
+			reconciler.Reconcile(context.Background(), desired, true)
 		})
 
 		AfterEach(func() {
@@ -369,7 +369,7 @@ var _ = Describe("ModelReconciler.Reconcile", func() {
 
 			labels := model.ObjectMeta.Labels
 
-			expectedLabels := GetModelOwnershipLabelsForHostingDeployment(*desired)
+			expectedLabels := GetResourceOwnershipLabelsForHostingDeployment(*desired)
 			for key, value := range expectedLabels {
 				Expect(labels).To(HaveKeyWithValue(key, value))
 			}
@@ -483,7 +483,7 @@ var _ = Describe("Delete ModelReconciler.Reconcile", func() {
 
 		var model modelv1.Model
 
-		err := reconciler.Reconcile(context.Background(), desired)
+		err := reconciler.Reconcile(context.Background(), desired, true)
 
 		err = k8sClient.Get(context.Background(), types.NamespacedName{
 			Namespace: k8sNamespace,
@@ -672,7 +672,7 @@ var _ = Describe("Update ModelReconciler.Reconcile", func() {
 		updated := desired.DeepCopy()
 		updated.Spec.Containers[0].ModelDataUrl = &newModelDataUrl
 
-		err := reconciler.Reconcile(context.Background(), updated)
+		err := reconciler.Reconcile(context.Background(), updated, true)
 		Expect(err).ToNot(HaveOccurred())
 
 		var model modelv1.Model
diff --git a/sagemaker-k8s-operator/controllers/model/model_controller.go b/sagemaker-k8s-operator/controllers/model/model_controller.go
index cc2ac4c..3f535ee 100644
--- a/sagemaker-k8s-operator/controllers/model/model_controller.go
+++ b/sagemaker-k8s-operator/controllers/model/model_controller.go
@@ -326,9 +326,16 @@ func (r *ModelReconciler) updateStatusWithAdditional(ctx reconcileRequestContext
 	return nil
 }
 
-// TODO Make sure this fits SageMaker validation https://docs.aws.amazon.com/sagemaker/latest/dg/API_CreateModel.html#SageMaker-CreateModel-request-ModelName
 func generateModelName(model *modelv1.Model) string {
-	return model.ObjectMeta.GetName() + "-" + strings.Replace(string(model.ObjectMeta.GetUID()), "-", "", -1)
+	sageMakerMaxNameLen := 63
+	name := model.ObjectMeta.GetName()
+	requiredPostfix := "-" + strings.Replace(string(model.ObjectMeta.GetUID()), "-", "", -1)
+
+	sageMakerModelName := name + requiredPostfix
+	if len(sageMakerModelName) > sageMakerMaxNameLen {
+		sageMakerModelName = name[:sageMakerMaxNameLen-len(requiredPostfix)] + requiredPostfix
+	}
+	return sageMakerModelName
 }
 
 // TODO add code that ignores status, metadata updates.
diff --git a/sagemaker-k8s-operator/controllers/sdkutil/clientwrapper/sagemaker_client.go b/sagemaker-k8s-operator/controllers/sdkutil/clientwrapper/sagemaker_client.go
index fe3fe49..2a4d09b 100644
--- a/sagemaker-k8s-operator/controllers/sdkutil/clientwrapper/sagemaker_client.go
+++ b/sagemaker-k8s-operator/controllers/sdkutil/clientwrapper/sagemaker_client.go
@@ -26,12 +26,16 @@ import (
 )
 
 const (
-	DeleteEndpoint404MessagePrefix        = "Could not find endpoint"
-	DeleteEndpoint404Code                 = "ValidationException"
-	DeleteEndpointInProgressMessagePrefix = "Cannot update in-progress endpoint"
-	DeleteEndpointInProgressCode          = "ValidationException"
-	DescribeEndpoint404MessagePrefix      = "Could not find endpoint"
-	DescribeEndpoint404Code               = "ValidationException"
+	DeleteEndpoint404MessagePrefix                        = "Could not find endpoint"
+	DeleteEndpoint404Code                                 = "ValidationException"
+	DeleteEndpointInProgressMessagePrefix                 = "Cannot update in-progress endpoint"
+	DeleteEndpointInProgressCode                          = "ValidationException"
+	DescribeEndpoint404MessagePrefix                      = "Could not find endpoint"
+	DescribeEndpoint404Code                               = "ValidationException"
+	UpdateEndpoint404MessagePrefix                        = "Could not find endpoint"
+	UpdateEndpoint404Code                                 = "ValidationException"
+	UpdateEndpointUnableToFindEndpointConfigMessagePrefix = "Could not find endpoint configuration"
+	UpdateEndpointUnableToFindEndpointConfigCode          = "ValidationException"
 
 	DescribeEndpointConfig404MessagePrefix = "Could not find endpoint configuration"
 	DescribeEndpointConfig404Code          = "ValidationException"
@@ -52,6 +56,7 @@ type SageMakerClientWrapper interface {
 	DescribeEndpoint(ctx context.Context, endpointName string) (*sagemaker.DescribeEndpointOutput, error)
 	CreateEndpoint(ctx context.Context, endpoint *sagemaker.CreateEndpointInput) (*sagemaker.CreateEndpointOutput, error)
 	DeleteEndpoint(ctx context.Context, endpointName *string) (*sagemaker.DeleteEndpointOutput, error)
+	UpdateEndpoint(ctx context.Context, endpointName, endpointConfigName string) (*sagemaker.UpdateEndpointOutput, error)
 
 	DescribeModel(ctx context.Context, modelName string) (*sagemaker.DescribeModelOutput, error)
 	CreateModel(ctx context.Context, model *sagemaker.CreateModelInput) (*sagemaker.CreateModelOutput, error)
@@ -116,6 +121,26 @@ func (c *sageMakerClientWrapper) isDeleteEndpoint404Error(err error) bool {
 	return false
 }
 
+// The SageMaker API does not conform to the HTTP standard. This detects if a SageMaker error response is equivalent
+// to an HTTP 404 not found.
+func (c *sageMakerClientWrapper) isUpdateEndpoint404Error(err error) bool {
+	if requestFailure, isRequestFailure := err.(awserr.RequestFailure); isRequestFailure {
+		return requestFailure.Code() == UpdateEndpoint404Code && strings.HasPrefix(requestFailure.Message(), UpdateEndpoint404MessagePrefix)
+	}
+
+	return false
+}
+
+// The SageMaker API does not conform to the HTTP standard. This detects if a SageMaker error response is equivalent
+// to an HTTP 404 not found.
+func (c *sageMakerClientWrapper) isUpdateEndpointUnableToFindEndpointConfigurationError(err error) bool {
+	if requestFailure, isRequestFailure := err.(awserr.RequestFailure); isRequestFailure {
+		return requestFailure.Code() == UpdateEndpointUnableToFindEndpointConfigCode && strings.HasPrefix(requestFailure.Message(), UpdateEndpointUnableToFindEndpointConfigMessagePrefix)
+	}
+
+	return false
+}
+
 // Create an Endpoint. Returns the response output or nil if error.
 func (c *sageMakerClientWrapper) CreateEndpoint(ctx context.Context, endpoint *sagemaker.CreateEndpointInput) (*sagemaker.CreateEndpointOutput, error) {
 
@@ -148,6 +173,28 @@ func (c *sageMakerClientWrapper) DeleteEndpoint(ctx context.Context, endpointNam
 	return deleteResponse.DeleteEndpointOutput, nil
 }
 
+// Delete an Endpoint. Returns the response output or nil if error.
+func (c *sageMakerClientWrapper) UpdateEndpoint(ctx context.Context, endpointName, endpointConfigName string) (*sagemaker.UpdateEndpointOutput, error) {
+	updateRequest := c.innerClient.UpdateEndpointRequest(&sagemaker.UpdateEndpointInput{
+		EndpointName:       &endpointName,
+		EndpointConfigName: &endpointConfigName,
+	})
+
+	updateResponse, updateError := updateRequest.Send(ctx)
+
+	if updateError != nil {
+
+		// Unfortunately both of these errors have the same prefix. We must check that it is 404 for Endpoint and not 404 for EndpointConfig.
+		// SageMaker will return 404 if the original (non-updating) EndpointConfig does not exist.
+		if c.isUpdateEndpoint404Error(updateError) && !c.isUpdateEndpointUnableToFindEndpointConfigurationError(updateError) {
+			return nil, nil
+		}
+		return nil, updateError
+	}
+
+	return updateResponse.UpdateEndpointOutput, nil
+}
+
 // Return a model description or nil if error.
 // If the object is not found, return a nil description and nil error.
 func (c *sageMakerClientWrapper) DescribeModel(ctx context.Context, modelName string) (*sagemaker.DescribeModelOutput, error) {
diff --git a/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/Chart.yaml b/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/Chart.yaml
new file mode 100644
index 0000000..288ca6c
--- /dev/null
+++ b/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/Chart.yaml
@@ -0,0 +1,9 @@
+apiVersion: v1
+name: sagemaker-k8s-trainingjob
+version: 0.1.0
+description: A Helm chart for deploying the SageMaker Batch Transform Job for Kubernetes.
+maintainers:
+  - name: Gautam Kumar
+    email: gauta@amazon.com
+  - name: Cade Daniel
+    email: cdnamz@amazon.com
diff --git a/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/templates/NOTES.txt b/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/templates/NOTES.txt
new file mode 100644
index 0000000..da850a1
--- /dev/null
+++ b/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/templates/NOTES.txt
@@ -0,0 +1,12 @@
+Thanks for installing the {{ .Chart.Name }}. 
+
+Your release is named {{ .Release.Name }}. 
+
+To learn more about the release, try:
+
+  $ helm status {{ .Release.Name }}
+  $ helm get {{ .Release.Name }}
+
+To use the latest features, try adding attributes to yaml by generating it:
+  
+  $ helm install <directory of charts> --debug --dry-run
diff --git a/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/templates/batch-transform-job.yaml b/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/templates/batch-transform-job.yaml
new file mode 100644
index 0000000..c74a5cd
--- /dev/null
+++ b/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/templates/batch-transform-job.yaml
@@ -0,0 +1,21 @@
+apiVersion: sagemaker.aws.amazon.com/v1
+kind: BatchTransformJob
+metadata:
+  name: {{ .Values.name }}
+spec:
+  region: {{ .Values.spec.region }}
+  modelName: {{ .Values.spec.modelname | quote }}
+  transformInput: 
+     dataSource: 
+       s3DataSource:
+          s3DataType: {{ .Values.spec.inputdataconfig.s3DataType | default "S3Prefix" }}
+          s3Uri: {{ .Values.spec.inputdataconfig.s3uri  }}
+     contentType: {{ .contenttype | default "text/csv" }}
+  transformOutput:
+    s3OutputPath: {{ .Values.spec.outputpath }}
+  transformResources:
+    instanceCount: {{ .Values.spec.instancecount }}
+    instanceType: {{ .Values.spec.instancetype }}
+  tags:
+    - key: test-key
+      value: test-value
diff --git a/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/values.yaml b/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/values.yaml
new file mode 100644
index 0000000..a5bb03f
--- /dev/null
+++ b/sagemaker-k8s-operator/hack/charts/batch-transform-jobs/values.yaml
@@ -0,0 +1,11 @@
+name: xgboost-mnist-batch-transform
+spec:	
+    instancecount: 1
+    instancetype: ml.m4.xlarge
+    region: us-west-2
+    modelname: sagemaker-tensorflow-2019-10-15-01-36-46-192 
+    inputdataconfig:
+       s3uri: s3://sagemaker-sample-data-us-west-2/batch-transform/mnist-1000-samples
+       s3datatype: S3Prefix
+    outputpath: s3://sagemaker-us-west-2-578276202366/sagemaker-tensorflow-2019-10-15-01-36-4-2019-10-15-04-00-11-585
+
diff --git a/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/Chart.yaml b/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/Chart.yaml
new file mode 100644
index 0000000..769eb9e
--- /dev/null
+++ b/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/Chart.yaml
@@ -0,0 +1,9 @@
+apiVersion: v1
+name: sagemaker-k8s-trainingjob
+version: 0.1.0
+description: A Helm chart for deploying the SageMaker Hyperparameter tuning job for Kubernetes.
+maintainers:
+  - name: Gautam Kumar
+    email: gauta@amazon.com
+  - name: Cade Daniel
+    email: cdnamz@amazon.com
diff --git a/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/templates/NOTES.txt b/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/templates/NOTES.txt
new file mode 100644
index 0000000..da850a1
--- /dev/null
+++ b/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/templates/NOTES.txt
@@ -0,0 +1,12 @@
+Thanks for installing the {{ .Chart.Name }}. 
+
+Your release is named {{ .Release.Name }}. 
+
+To learn more about the release, try:
+
+  $ helm status {{ .Release.Name }}
+  $ helm get {{ .Release.Name }}
+
+To use the latest features, try adding attributes to yaml by generating it:
+  
+  $ helm install <directory of charts> --debug --dry-run
diff --git a/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/templates/hpo-job.yaml b/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/templates/hpo-job.yaml
new file mode 100644
index 0000000..d0b13a3
--- /dev/null
+++ b/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/templates/hpo-job.yaml
@@ -0,0 +1,74 @@
+apiVersion: sagemaker.aws.amazon.com/v1
+kind: HyperparameterTuningJob
+metadata:
+  name: {{ .Values.name }}
+spec:
+    hyperParameterTuningJobConfig:
+        resourceLimits:
+            maxNumberOfTrainingJobs:  {{ .Values.spec.hyperparametertuningjobconfig.maxnumberoftrainingjobs}}
+            maxParallelTrainingJobs:  {{ .Values.spec.hyperparametertuningjobconfig.maxparalleltrainingjobs }}
+        strategy: {{ .Values.spec.hyperparametertuningjobconfig.strategy | quote }}
+    region: {{ .Values.spec.region }}
+    tags:
+      - key: test-key
+        value: test-value
+    hyperParameterTuningJobConfig:
+      strategy: {{ .Values.spec.hyperparametertuningjobconfig.strategy | quote }}
+      hyperParameterTuningJobObjective:
+        type: {{ .Values.spec.hyperparametertuningjobconfig.hyperparametertuningjobobjective.type }}
+        metricName:  {{ .Values.spec.hyperparametertuningjobconfig.hyperparametertuningjobobjective.metricname }}
+      resourceLimits:
+        maxNumberOfTrainingJobs: {{ .Values.spec.hyperparametertuningjobconfig.maxnumberoftrainingjobs}}
+        maxParallelTrainingJobs: {{ .Values.spec.hyperparametertuningjobconfig.maxparalleltrainingjobs }}
+      parameterRanges:
+        integerParameterRanges:
+           - name:  {{ .Values.spec.hyperparametertuningjobconfig.integerparameterranges.name }}
+             minValue: {{ .Values.spec.hyperparametertuningjobconfig.integerparameterranges.minvalue | quote }}
+             maxValue: {{ .Values.spec.hyperparametertuningjobconfig.integerparameterranges.maxvalue | quote }}
+             scalingType: {{ .Values.spec.hyperparametertuningjobconfig.integerparameterranges.scalingtype }}
+        # Add support for next two ranges in values.yaml
+        continuousParameterRanges: []
+        categoricalParameterRanges: []
+      trainingJobEarlyStoppingType: Auto
+    trainingJobDefinition:
+      staticHyperParameters:
+         {{- range $key, $value := .Values.spec.trainingjobconfig.hyperparameters }}
+         - name: {{ $key }}
+           value: {{ $value | quote }}
+         {{- end }}
+      algorithmSpecification:
+        trainingImage: {{ .Values.spec.image }}
+        trainingInputMode: {{ .Values.spec.traininginputmode }}
+      roleArn: {{ .Values.spec.rolearn }}
+      inputDataConfig:
+            {{- range .Values.spec.inputdataconfig }}
+              - channelName: {{ .channel }}  
+                dataSource: 
+                  {{- if .s3 }}
+                  s3DataSource:
+                     s3DataType: {{ .s3.s3datatype | default "S3Prefix" }}
+                     s3Uri: {{ .s3.s3uri }}
+                     s3DataDistributionType: {{ .s3.s3datadistributiontype | default "FullyReplicated" }}
+                  {{- end }}
+                  {{- if .filesystem }}
+                  fileSystemDataSource: 
+                      fileSystemId: {{ .filesystem.filesystemid }}
+                      fileSystemAccessMode: {{ .filesystemaccessmode | default "ro" }}
+                      fileSystemType: {{ .filesystem.filesystemtype }}
+                      directoryPath: {{ .filesystem.directorypath }}
+                  {{- end }}
+                contentType: {{ .contenttype | default "text/csv" }}
+                compressionType: {{ .compressiontype | default "None" }}
+                recordWrapperType: {{ .recordwrappertype | default "None" }}
+                inputMode: {{ .inputmode | default "File" }}
+            {{- end }}
+      outputDataConfig:
+        s3OutputPath: {{ .Values.spec.outputpath }}
+      resourceConfig:
+        instanceType: {{ .Values.spec.instancetype }}
+        instanceCount: {{ .Values.spec.instancecount }}
+        volumeSizeInGB: {{ .Values.spec.volumesize }}
+      stoppingCondition:
+        maxRuntimeInSeconds: {{ .Values.spec.maxruntimeinseconds }}
+      enableNetworkIsolation: {{ .Values.spec.enablenetworkisolation }}
+      enableInterContainerTrafficEncryption: {{ .Values.spec.enableintercontainertrafficencryption }} 
diff --git a/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/values.yaml b/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/values.yaml
new file mode 100644
index 0000000..ddbe45e
--- /dev/null
+++ b/sagemaker-k8s-operator/hack/charts/hyperparameter-tuning-jobs/values.yaml
@@ -0,0 +1,57 @@
+name: xgboost-mnist-hpo
+spec:   
+    instancecount: 1
+    instancetype: ml.m4.xlarge
+    volumesize: 35
+    maxruntimeinseconds: 86400
+    rolearn: arn:aws:iam::578276202366:role/service-role/AmazonSageMaker-ExecutionRole-20190614T120659
+    region: us-east-2
+    image: 825641698319.dkr.ecr.us-east-2.amazonaws.com/xgboost:1
+    enablenetworkisolation: true
+    enableintercontainertrafficencryption: false
+    traininginputmode: File
+    hyperparametertuningjobconfig:
+      maxnumberoftrainingjobs: 10
+      maxparalleltrainingjobs: 10
+      strategy: Bayesian
+      hyperparametertuningjobobjective: 
+         type: Minimize
+         metricname: validation:error
+      integerparameterranges:
+         name: num_round
+         minvalue: 10
+         maxvalue: 20
+         scalingtype: Linear
+    trainingjobconfig: 
+      hyperparameters:
+        base_score: '0.5' 
+        booster: gbtree
+        csv_weights: '0'
+        dsplit: row
+        grow_policy: depthwise
+        lambda_bias: '0.0'
+        max_bin: '256'
+        max_leaves: '0' 
+        normalize_type: tree
+        objective: reg:linear
+        one_drop: '0' 
+        prob_buffer_row: '1.0'
+        process_type: default
+        rate_drop: '0.0'
+        refresh_leaf: '1'
+        sample_type: uniform
+        scale_pos_weight: '1.0'
+        silent: '0'
+        sketch_eps: '0.03'
+        skip_drop: '0.0'
+        tree_method: auto
+        tweedie_variance_power: '1.5'
+        updater: grow_colmaker,prune
+    inputdataconfig:
+      - channel: train 
+        s3: 
+           s3uri: https://s3-us-east-2.amazonaws.com/cdnamz-sagemaker-operator-training-data/sagemaker/xgboost-mnist/train/
+      - channel: validation
+        s3: 
+           s3uri: https://s3-us-east-2.amazonaws.com/cdnamz-sagemaker-operator-training-data/sagemaker/xgboost-mnist/validation/
+    outputpath: s3://cdnamz-sagemaker-operator-training-data/sagemaker/xgboost-mnist/xgboost/
diff --git a/sagemaker-k8s-operator/smlogs-kubectl-plugin/go.mod b/sagemaker-k8s-operator/smlogs-kubectl-plugin/go.mod
index a0fd90b..9ab77f1 100644
--- a/sagemaker-k8s-operator/smlogs-kubectl-plugin/go.mod
+++ b/sagemaker-k8s-operator/smlogs-kubectl-plugin/go.mod
@@ -17,7 +17,7 @@ require (
 
 replace (
 	// https://stackoverflow.com/a/52330233 . Remove once we have package available for consumption.
-	go.amzn.com/sagemaker/sagemaker-k8s-operator => ../sagemaker-k8s-operator
+	go.amzn.com/sagemaker/sagemaker-k8s-operator => ../
 	golang.org/x/crypto => golang.org/x/crypto v0.0.0-20181025213731-e84da0312774
 	golang.org/x/net => golang.org/x/net v0.0.0-20190206173232-65e2d4e15006
 	golang.org/x/sync => golang.org/x/sync v0.0.0-20181108010431-42b317875d0f
-- 
2.17.2 (Apple Git-113)

